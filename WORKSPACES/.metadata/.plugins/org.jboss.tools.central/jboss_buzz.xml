<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><entry><title>How to use Fabric8 Kubernetes Client</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/01/05/how-use-fabric8-kubernetes-client" /><author><name>Rohan Kumar</name></author><id>7362e20f-58c7-48cc-815a-f1694e695c42</id><updated>2023-01-05T07:00:00Z</updated><published>2023-01-05T07:00:00Z</published><summary type="html">&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;While working with Kubernetes Client, you would mostly be working with standard Kubernetes resources whose model is provided by the library itself. However, it’s not always possible to provide a concrete model type while accessing a Kubernetes API object (e.g. in case of Custom Resources). Fabric8 Kubernetes Client’s &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CHEATSHEET.md#resource-typeless-api"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;GenericKubernetesResource API&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; can be used in these scenarios. It allows objects that do not have java POJOs registered to be manipulated generically. &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;This article is the third installment in this series:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Part 1: &lt;a href="https://developers.redhat.com/articles/2023/01/04/how-use-fabric8-java-client-kubernetes"&gt;How to use Fabric8 Java Client with Kubernetes&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 2:  &lt;a href="https://developers.redhat.com/articles/2023/01/04/programming-kubernetes-custom-resources-java"&gt;Programming Kubernetes custom resources in Java&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 3:  How to use Fabric8 Kubernetes Client&lt;/li&gt; &lt;li&gt;Part 4 (coming soon): Programming Kubernetes in Java | code generation (WIP)&lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Getting the Fabric8 Kubernetes client&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; &lt;p&gt;&lt;a href="https://github.com/fabric8io/kubernetes-client"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;Fabric8 Kubernetes Client&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; library should be available on &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://search.maven.org/search?q=g:io.fabric8%20a:kubernetes-client"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;Maven Central&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;. If you’re using maven, you should be able to add it as a dependency in your project by adding this to your &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;dependencies&lt;/code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; section of your &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;pom.xml&lt;/code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;dependency&gt;   &lt;groupId&gt;io.fabric8&lt;/groupId&gt;   &lt;artifactId&gt;kubernetes-client&lt;/artifactId&gt;   &lt;version&gt;6.2.0&lt;/version&gt; &lt;/dependency&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Gradle users need to add this to &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;build.gradle&lt;/code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;implementation 'io.fabric8:kubernetes-client:6.2.0'&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;The GenericKubernetesResource object&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; &lt;p&gt;&lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/kubernetes-model-generator/kubernetes-model-core/src/main/java/io/fabric8/kubernetes/api/model/GenericKubernetesResource.java"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;GenericKubernetesResource&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; is a generic Kubernetes object which can be used to serialize/deserialize any Kubernetes resource. It allows basic access to type metadata and object metadata. All the other stuff needs to be provided in additionalProperties map. While deserializing an unknown resource, common stuff like apiVersion, kind and metadata would be directly available but rest would be in additionalProperties map.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Let’s take a look at an example of creating a GenericKubernetesResource object. We will take example from &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#create-custom-objects"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;Kubernetes CustomResourceDefinition docs&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; for CronTab object:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;pre&gt; &lt;code class="language-yaml"&gt;# Taken from https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#create-custom-objects apiVersion: "stable.example.com/v1" kind: CronTab metadata:   name: my-new-cron-object spec:   cronSpec: "* * * * */5"   image: my-awesome-cron-image&lt;/code&gt;&lt;/pre&gt; &lt;p&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;We can represent this object in GenericKubernetesResource like this:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;Map&lt;String, Object&gt; spec = new HashMap&lt;&gt;(); spec.put("cronSpec", "* * * * */5"); spec.put("image", "my-awesome-cron-image"); GenericKubernetesResource genericKubernetesResource = new GenericKubernetesResourceBuilder()     .withApiVersion("stable.example.com/v1")     .withKind("CronTab")     .withNewMetadata()     .withName("my-new-cron-object")     .endMetadata()     .addToAdditionalProperties("spec", spec)     .build(); System.out.println(Serialization.asYaml(genericKubernetesResource));&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Note that access to type and object metadata is similar to standard Kubernetes resources. However, other fields (like status and spec) are manipulated using plain HashMaps.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2 entry points for dynamic client&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;There are different ways to use GenericKubernetesResource API in Fabric8 Kubernetes Client. Let’s take a look at two approaches:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Providing apiVersion and kind&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;You can start using GenericKubernetesResource API by providing apiVersion and kind to &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;code&gt;kubernetesClient.genericKubernetesResources()&lt;/code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; method. Here is an example of creating CronTab object we constructed in the previous section: &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;pre&gt; &lt;code class="language-java"&gt;try (KubernetesClient client = new KubernetesClientBuilder().build()) {   GenericKubernetesResource genericKubernetesResource = createNewCronTab();                                     // ApiVersion              // Kind   client.genericKubernetesResources("stable.example.com/v1", "CronTab")       .inNamespace("default")       .resource(genericKubernetesResource)       .create(); }&lt;/code&gt;&lt;/pre&gt; This method would automatically detect resource-related information like group, version, and plural that are required for contacting Kubernetes API server.&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Providing ResourceDefinitionContext:&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;We can go one step further from the previous approach by providing all the resource-related information to KubernetesClient rather than letting KubenetesClient make assumptions. We can do this by providing information in the form of ResourceDefinitionContext. Check this example:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;pre&gt; &lt;code class="language-java"&gt;try (KubernetesClient client = new KubernetesClientBuilder().build()) {   GenericKubernetesResource genericKubernetesResource = createNewCronTab();   ResourceDefinitionContext context = new ResourceDefinitionContext.Builder()       .withGroup("stable.example.com")       .withVersion("v1")       .withKind("CronTab")       .withPlural("crontabs")       .withNamespaced(true)       .build();   client.genericKubernetesResources(context)       .inNamespace("default")       .resource(genericKubernetesResource)       .create(); }&lt;/code&gt;&lt;/pre&gt; &lt;/li&gt; &lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Basic create, read, update, delete operations&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Once you’ve provided ResourceDefinitionContext or apiVersion+kind to genericKubernetesResources() DSL method, it’s very easy to perform basic operations since they are the same as standard Kubernetes resources, thanks to KubernetesClient’s fluent DSL.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;The next code snippet gives an overview of the basic operations of CronTab custom resource:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Watch operation&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Like common operations, it’s also possible to watch a resource with the help of GenericKubernetesResource API. Here is an example:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;try (KubernetesClient client = new KubernetesClientBuilder().build()) {   Watch watch = client.genericKubernetesResources("stable.example.com/v1", "CronTab")       .inNamespace("default")       .watch(new Watcher&lt;&gt;() {         @Override         public void eventReceived(Action action, GenericKubernetesResource genericKubernetesResource) {           logger.info("{} {}", action.name(), genericKubernetesResource.getMetadata().getName());         }         @Override         public void onClose(WatcherException e) {           logger.info("Closing due to {} ", e.getMessage());         }       });   logger.info("Watch open for 30 seconds");   Thread.sleep(30 * 1000L);   watch.close();   logger.info("Watch closed"); }&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Fabric8 Kubernetes client GitHub&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;This article demonstrated how to manipulate Kubernetes CustomResource API using Fabric8 Kubernetes Client. You can find the code in this &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo"&gt;repository&lt;/a&gt;. Stay tuned for the final article in this series discussing &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;code generation (WIP).&lt;/p&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;For more information, check out the &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://github.com/fabric8io/kubernetes-client"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;Fabric8 Kubernetes Client GitHub&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; page. Feel free to follow us on these channels:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt;&lt;li aria-level="1"&gt;&lt;a href="https://stackoverflow.com/questions/tagged/fabric8"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;StackOverflow&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CHEATSHEET.md"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;Fabric8 Kubernetes Client CHEATSHEET&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://twitter.com/fabric8io"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;Twitter&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://gitter.im/fabric8io/kubernetes-client"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;Gitter Chat&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/01/05/how-use-fabric8-kubernetes-client" title="How to use Fabric8 Kubernetes Client"&gt;How to use Fabric8 Kubernetes Client&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Rohan Kumar</dc:creator><dc:date>2023-01-05T07:00:00Z</dc:date></entry><entry><title type="html">Introduction to Maven Daemon (mvnd)</title><link rel="alternate" href="http://www.mastertheboss.com/jboss-frameworks/jboss-maven/introduction-to-maven-daemon-mvnd/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/jboss-frameworks/jboss-maven/introduction-to-maven-daemon-mvnd/</id><updated>2023-01-04T09:49:03Z</updated><content type="html">Maven Daemon (mvnd) is a background process that can speed up Maven builds by keeping a daemon process running in the background. This allows Maven to start up faster, as it does not have to initialize the build process from scratch for each build. In this tutorial, we will cover how to install and configure ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>Programming Kubernetes custom resources in Java</title><link rel="alternate" href="https://developers.redhat.com/articles/2023/01/04/programming-kubernetes-custom-resources-java" /><author><name>Rohan Kumar</name></author><id>02b2678c-8b3d-43b7-99e2-e102a87a26a6</id><updated>2023-01-04T07:00:00Z</updated><published>2023-01-04T07:00:00Z</published><summary type="html">&lt;p&gt;Kubernetes 1.16 introduced the concept of &lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/"&gt;custom resources&lt;/a&gt; (CRs), allowing users to define their own Kubernetes objects that can be used in their applications. Users are now able to define these Kubernetes object structures tailored to their needs and use them like native Kubernetes resources. This makes Kubernetes much more extensible. These custom resources can be used by Kubernetes Operators to manage applications and their components.&lt;/p&gt; &lt;p&gt;This article is the second installment in this series:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;Part 1: &lt;a href="https://developers.redhat.com/articles/2023/01/04/how-use-fabric8-java-client-kubernetes"&gt;How to use Fabric8 Java Client with Kubernetes&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 2:  Programming Kubernetes custom resources in Java&lt;/li&gt; &lt;li&gt;Part 3:  &lt;a href="https://developers.redhat.com/articles/2023/01/05/how-use-fabric8-kubernetes-client"&gt;How to use Fabric8 Kubernetes Client&lt;/a&gt;&lt;/li&gt; &lt;li&gt;Part 4 (coming soon): Programming Kubernetes in Java | code generation (WIP)&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;In this article, you'll see how you can manipulate the Kubernetes custom resource API programmatically in Java using the Fabric8 Kubernetes client. You'll see some common use cases while using Kubernetes custom resources and try to implement those in Java using the Fabric8 Kubernetes client.&lt;/p&gt; &lt;h2&gt;Getting the client&lt;/h2&gt; &lt;p&gt;The &lt;a href="https://github.com/fabric8io/kubernetes-client"&gt;Fabric8 Kubernetes client library&lt;/a&gt; should be available on &lt;a href="https://search.maven.org/search?q=g:io.fabric8%20a:kubernetes-client"&gt;Maven Central&lt;/a&gt;. If you're using Maven, you should be able to add it as a dependency in your project by adding the following to the &lt;code&gt;&lt;dependencies&gt;&lt;/code&gt; section of your &lt;code&gt;pom.xml&lt;/code&gt; file:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-xml"&gt;&lt;dependency&gt;   &lt;groupId&gt;io.fabric8&lt;/groupId&gt;   &lt;artifactId&gt;kubernetes-client&lt;/artifactId&gt;   &lt;version&gt;6.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Gradle users need to add the following to &lt;code&gt;build.gradle&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;implementation 'io.fabric8:kubernetes-client:6.1.1' &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;CustomResource POJOs&lt;/h2&gt; &lt;p&gt;We're going to consider the Fabric8 Kubernetes client's typed API here, which means we need to provide a &lt;code&gt;CustomResource&lt;/code&gt; type to Fabric8 Kubernetes Client. For this, we need to define some plain Java classes as per our &lt;code&gt;CustomResource&lt;/code&gt;'s structure. We could use tools like &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/java-generation-from-CRD.md"&gt;Fabric8 Java Generator&lt;/a&gt; or &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CRD-generator.md"&gt;Fabric8 CRD Generator&lt;/a&gt; to automatically generate these files instead, but we will cover that process in a separate article.&lt;/p&gt; &lt;p&gt;All &lt;code&gt;CustomResources&lt;/code&gt; defined to Fabric8 Kubernetes Client must extend the &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/kubernetes-client-api/src/main/java/io/fabric8/kubernetes/client/CustomResource.java"&gt;io.fabric8.kubernetes.client.CustomResource&lt;/a&gt; class. Let's take a look at that class:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;public abstract class CustomResource&lt;S, T&gt; implements HasMetadata { // ... } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;As you can see, it's a generic class that seems to have two arguments:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;The first argument is for &lt;code&gt;CustomResource&lt;/code&gt;'s &lt;code&gt;spec&lt;/code&gt; field&lt;/li&gt; &lt;li&gt;The second argument is for &lt;code&gt;CustomResource&lt;/code&gt;'s &lt;code&gt;status&lt;/code&gt; field&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;Why does the Fabric8 Kubernetes client require you to have these fields in the &lt;code&gt;CustomResource&lt;/code&gt;? All Kubernetes primitive types (except some types in the core and RBAC &lt;code&gt;apiGroup&lt;/code&gt;s) seem to have spec and status in their bodies. The main motivation behind this is the separation of concerns:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;code&gt;spec&lt;/code&gt; is something that the user specifies. It's the user's way of providing the input for the desired state of that object.&lt;/li&gt; &lt;li&gt;&lt;code&gt;status&lt;/code&gt; is something that should not be modified by the user. It should be the implemented controller/Operator's responsibility to update this field to provide the current state of that object.&lt;/li&gt; &lt;/ul&gt;&lt;p&gt;The most common application of &lt;code&gt;CustomResource&lt;/code&gt;s is Kubernetes Operators. Therefore, it's advisable to use &lt;code&gt;spec&lt;/code&gt; and &lt;code&gt;status&lt;/code&gt; fields when using CustomResources.&lt;/p&gt; &lt;p&gt;Let's take a look at the Java classes for a &lt;code&gt;Book&lt;/code&gt; custom resource definition. Here's &lt;code&gt;Book.java&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;package io.fabric8.crd.model.v1alpha1; import io.fabric8.kubernetes.api.model.Namespaced; import io.fabric8.kubernetes.client.CustomResource; import io.fabric8.kubernetes.model.annotation.Group; import io.fabric8.kubernetes.model.annotation.Version; @Version("v1alpha1") // -&gt; CRD Version @Group("testing.fabric8.io") // -&gt; CRD Group public class Book // -&gt; CRD Kind (if not provided in @Kind annotation) extends CustomResource&lt;BookSpec, BookStatus&gt; // -&gt; .spec -&gt; BookSpec , .status -&gt; BookStatus implements Namespaced { } // -&gt; CRD scope Namespaced&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Here's &lt;code&gt;BookSpec.java&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;package io.fabric8.crd.model.v1alpha1; public class BookSpec { private String title; private String author; private String isbn; public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getIsbn() { return isbn; } public void setIsbn(String isbn) { this.isbn = isbn; } }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;And here's &lt;code&gt;BookStatus.java&lt;/code&gt;&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;package io.fabric8.crd.model.v1alpha1; public class BookStatus { private boolean issued; private String issuedto; public boolean isIssued() { return issued; } public void setIssued(boolean issued) { this.issued = issued; } public String getIssuedto() { return issuedto; } public void setIssuedto(String issuedto) { this.issuedto = issuedto; } } &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Creating the custom resource definition&lt;/h2&gt; &lt;p&gt;Just as you would in Java before creating a custom object, to make a custom resource definition you need to create a class first. In order to use a custom resource, you need to first define its structure and register it to the Kubernetes API server in the form of a &lt;code&gt;CustomResourceDefinition&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;We will be taking an example of a simple custom resource called &lt;code&gt;Book&lt;/code&gt;. The code snippet below defines the &lt;code&gt;CustomResourceDefinition&lt;/code&gt; using the Fabric8 Kubernetes client. It's also possible to automatically generate its YAML file using &lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CRD-generator.md"&gt;Fabric8 CRD Generator&lt;/a&gt;; we will be covering that in a separate article.&lt;/p&gt; &lt;p&gt;As you can see, we have defined the structure of our custom resource in the &lt;code&gt;openAPIV3Schema&lt;/code&gt; field. You can create a &lt;code&gt;CustomResourceDefinition&lt;/code&gt; either using &lt;code&gt;kubectl&lt;/code&gt; or using Fabric8 Kubernetes Client, like this:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;try (KubernetesClient client = new KubernetesClientBuilder().build()) { CustomResourceDefinition crd = v1CRDFromCustomResourceType(Book.class) .editSpec().editVersion(0) .withNewSchema() .withNewOpenAPIV3Schema() .withType("object") .addToProperties("spec", new JSONSchemaPropsBuilder() .withType("object") .addToProperties("title", new JSONSchemaPropsBuilder() .withType("string") .build()) .addToProperties("author", new JSONSchemaPropsBuilder() .withType("string") .build()) .addToProperties("isbn", new JSONSchemaPropsBuilder() .withType("string") .build()) .build()) .addToProperties("status", new JSONSchemaPropsBuilder() .withType("object") .addToProperties("issued", new JSONSchemaPropsBuilder() .withType("boolean") .build()) .addToProperties("issuedto", new JSONSchemaPropsBuilder() .withType("string") .build()) .build()) .endOpenAPIV3Schema() .endSchema() .endVersion().endSpec().build(); client.apiextensions().v1() .customResourceDefinitions() .resource(crd) .create(); } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Once you've created Book CustomResourceDefinition, you can start using Book CustomResource.&lt;/p&gt; &lt;h2&gt;Basic CRUD operations&lt;/h2&gt; &lt;p&gt;If you are already familiar with the Kubernetes client, you'll notice that basic Create, Read, Update, Delete (CRUD) operations for custom resources are not that different from those for regular resources. There is an additional process involved in creating an operation instance for that specific custom resource. Take our &lt;code&gt;Book&lt;/code&gt; custom resource as an example. We would need to create a &lt;code&gt;MixedOperation&lt;/code&gt; instance like this:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;MixedOperation&lt;Book, KubernetesResourceList&lt;Book&gt;, Resource&lt;Book&gt;&gt; bookOp = client.resources(Book.class);&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Once you've created this object, you can do basic operations:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;try (KubernetesClient client = new KubernetesClientBuilder().build()) { // Create Book Client MixedOperation&lt;Book, KubernetesResourceList&lt;Book&gt;, Resource&lt;Book&gt;&gt; bookOp = client.resources(Book.class); // Create Book Object Book book1 = createNewBook("head-first-java", "Head First Java", "Kathy Sierra", "9781491910771"); // Create bookOp.inNamespace("default").resource(book1).create(); // Read book1 = bookOp.inNamespace("default").withName("head-first-java").get(); // List KubernetesResourceList&lt;Book&gt; books = bookOp.inNamespace("default").list(); books.getItems().stream().map(CustomResource::getMetadata).map(ObjectMeta::getName).forEach(logger::info); // Update book1.getSpec().setAuthor("Kathy Sierra, Bert Bates, Trisha Gee"); bookOp.inNamespace("default").resource(book1).replace(); // Delete bookOp.inNamespace("default").resource(book1).delete(); } &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Updating status&lt;/h2&gt; &lt;p&gt;This use case is very common when working on Kubernetes Operators' control loop. Kubernetes Operators are supposed to update the status of a custom resource after processing it during reconciliation. We will be using the same &lt;code&gt;Book&lt;/code&gt; custom resource here and try to update its status:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;try (KubernetesClient client = new KubernetesClientBuilder().build()) { MixedOperation&lt;Book, KubernetesResourceList&lt;Book&gt;, Resource&lt;Book&gt;&gt; bookOp = client.resources(Book.class); // Create Book CR Book book1 = createNewBook("effective-java", "Effective Java", "Joshua Bloch ", "9788131726594"); book1 = bookOp.inNamespace("default").resource(book1).create(); // Create Status Object BookStatus book1Status = new BookStatus(); book1Status.setIssued(true); book1Status.setIssuedto("Bob"); // Update Status book1.setStatus(book1Status); bookOp.inNamespace("default").resource(book1).replaceStatus(); } &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Custom resource shared informers&lt;/h2&gt; &lt;p&gt;While using custom resources in applications, it's better to use shared informers rather than plain watch. It's the same as using shared informers for regular resources, with the additional step of creating a client for the custom resource:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;try (KubernetesClient client = new KubernetesClientBuilder().build()) { MixedOperation&lt;Book, KubernetesResourceList&lt;Book&gt;, Resource&lt;Book&gt;&gt; bookOp = client.resources(Book.class); SharedIndexInformer&lt;Book&gt; bookSharedIndexInformer = bookOp.inNamespace("default").inform(new ResourceEventHandler&lt;&gt;() { @Override public void onAdd(Book book) { logger.info("{} ADDED"); } @Override public void onUpdate(Book book, Book t1) { logger.info("{} UPDATED"); } @Override public void onDelete(Book book, boolean b) { logger.info("{} DELETED"); } }); Thread.sleep(30 * 1000L); logger.info("Book SharedIndexInformer open for 30 seconds"); bookSharedIndexInformer.close(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException(e); } &lt;/code&gt;&lt;/pre&gt; &lt;h2 id="learn_more_about_programming_kubernetes_in_java-h2"&gt;Learn more about programming Kubernetes in Java&lt;/h2&gt; &lt;p&gt;This article has shown how to manipulate the Kubernetes custom resource API using the Fabric8 Kubernetes client. You can find all the code for this in &lt;a href="https://github.com/rohanKanojia/kubernetes-client-demo"&gt;this repository&lt;/a&gt;. The next article, &lt;a href="https://developers.redhat.com/articles/2023/01/05/programming-kubernetes-java-dynamic-client"&gt;How to use Fabric8 Kubernetes Client&lt;/a&gt;, demonstrates the Fabric8 Kubernetes Dynamic Client. &lt;/p&gt; &lt;p&gt;For more information, check out the &lt;a href="https://github.com/fabric8io/kubernetes-client"&gt;Fabric8 Kubernetes Client GitHub&lt;/a&gt; page. Feel free to follow us on these channels:&lt;/p&gt; &lt;ul&gt;&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/tagged/fabric8"&gt;StackOverflow&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://github.com/fabric8io/kubernetes-client/blob/master/doc/CHEATSHEET.md"&gt;Fabric8 Kubernetes Client CHEATSHEET&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://twitter.com/fabric8io"&gt;Twitter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="https://gitter.im/fabric8io/kubernetes-client"&gt;Gitter Chat&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; The post &lt;a href="https://developers.redhat.com/articles/2023/01/04/programming-kubernetes-custom-resources-java" title="Programming Kubernetes custom resources in Java"&gt;Programming Kubernetes custom resources in Java&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Rohan Kumar</dc:creator><dc:date>2023-01-04T07:00:00Z</dc:date></entry><entry><title>Quarkus 2.15.2.Final released - Maintenance release</title><link rel="alternate" href="&#xA;                https://quarkus.io/blog/quarkus-2-15-2-final-released/&#xA;            " /><author><name>Guillaume Smet (https://twitter.com/gsmet_)</name></author><id>https://quarkus.io/blog/quarkus-2-15-2-final-released/</id><updated>2023-01-04T00:00:00Z</updated><published>2023-01-04T00:00:00Z</published><summary type="html">The Quarkus team wishes you a happy new year, and with the new year comes a new Quarkus release, 2.15.2.Final. This version contains bugfixes and documentation improvements for our 2.15 release train. It is a recommended upgrade for anyone already using 2.15. If you are not already using 2.15, please...</summary><dc:creator>Guillaume Smet (https://twitter.com/gsmet_)</dc:creator><dc:date>2023-01-04T00:00:00Z</dc:date></entry><entry><title type="html">New feature: Serverless Workflow code completions</title><link rel="alternate" href="https://blog.kie.org/2023/01/new-feature-serverless-workflow-code-completions.html" /><author><name>Fabrizio Antonangeli</name></author><id>https://blog.kie.org/2023/01/new-feature-serverless-workflow-code-completions.html</id><updated>2023-01-03T16:21:47Z</updated><content type="html">Starting to write a valid workflow can be a bit difficult and requires you to remember the syntax with the node’s properties and the specification’s rules. We implemented a new feature in Serverless Workflow Editor to guide the user and make this process easier resulting in a richer IntelliSense editor. Here we will have a quick overview of these features. REQUIREMENTS * (1.66.0+); * (0.26.0) , there is a ready-to-use online version of the Serverless Workflow Editor to try the new functionality using one of the provided samples or creating a new Serverless Workflow. THE NEW CODE LENSES AND CODE COMPLETIONS To implement the new features, we used the Code Lenses and the Code Completions of Monaco Editor, which is the editor used in Serverless Logic Web Tools and the built-in editor in VS Code. This way we ensure to have exactly the same behaviour between the two environments and we reuse the same implementation. These features are available in JSON and YAML workflows and are powered by 2 language services, depending on the language you use. The keyboard shortcut to activate the Code Completions is Ctrl+Space, as usual, and some properties, like functions and states, can be activated by the mouse, using the Code Lenses over the property name in the Serverless Workflow file. When you activate a completion, a dropdown appears to let you choose which suggestion you want. By default with Tab or Shift+Tab, you can move to the next or previous placeholder of the suggestion, and then with Enter, you select your choice. You can always change the suggestion behaviour in VS Code settings. In some cases, we also implemented “context-based code completions” showing suggestions related to the specific property you are writing. CREATE A NEW SERVERLESS WORKFLOW If you don’t know by heart the specification, you probably need to switch between the documentation and your Serverless Workflow, during its creation.  The first feature we show will help you with this initial step. You can activate the Code Completion with Ctrl+Space or the Code Lenses “Create a Serverless Workflow” over the first line. This completion has many placeholders and lets you initialize your workflow with a function, an event and a state. EDITING A SERVERLESS WORKFLOW There are more code completions we implemented. In this section, we will see more in detail. FUNCTIONS NODE SUGGESTIONS For these suggestions, the information is fetched from registered Service Registries on VS Code settings and/or local spec files stored locally in the specs folder: * Suggest a generic function, to provide the user with a template to start. * Suggest the operation value in the function node from the imported service STATES NODE SUGGESTIONS For these suggestions, the information is taken from all the state names for transition nodes, for functionRef nodes from the functions node and from event names for eventRef nodes. * Suggest the most common type of states, to provide the user with some templates to start. * Suggest the names of the possible states for transitions properties in the state node or in eventConditions, defaultCondition and dataConditions nodes. * Suggest functionRef arguments and functionRef refName or the whole functionRef in a state node fetching them from the Service Registries * Suggest all the state’s names for start property completion, at the root level * Suggest the names of the possible events for eventRefs properties. EVENTS NODE SUGGESTIONS Here we only provide a template for a generic event to help the user create an event. For instance, you want to create an event “NewGreetEvent” then you create a state and in the eventRefs property, the editor will suggest you the event “NewGreetEvent” while in the transition property you will see the other states as a suggestion. CONCLUSION We are working to make the “learning curve” not too steep, helping people starting with Serverless Workflow, not requiring a deep knowledge of the Serverless Workflow specification. In addition, avoiding unwanted typos or syntax errors is another advantage of "context-based code completions", where code suggestions are based on possible values taken from the code itself or even from a server. The post appeared first on .</content><dc:creator>Fabrizio Antonangeli</dc:creator></entry><entry><title type="html">Migrating a Service from JBoss ESB to Apache Camel</title><link rel="alternate" href="http://www.mastertheboss.com/articles/jboss-esb/migrating-a-service-from-jboss-esb-to-apache-camel/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/articles/jboss-esb/migrating-a-service-from-jboss-esb-to-apache-camel/</id><updated>2023-01-03T14:38:08Z</updated><content type="html">If you have a service running on JBoss ESB and are looking to migrate to a different platform, Apache Camel can be a good choice. Camel is a widely-used, open-source integration framework that allows you to define routing and mediation rules in a variety of domain-specific languages, including a Java-based Fluent API, Spring XML, and ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">Comparing OpenID Connect with OAuth 2.0</title><link rel="alternate" href="http://www.mastertheboss.com/keycloak/comparing-openid-connect-with-oauth-2-0/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/keycloak/comparing-openid-connect-with-oauth-2-0/</id><updated>2023-01-03T13:53:42Z</updated><content type="html">OpenID Connect (OIDC) and OAuth 2.0 are two popular protocols you can use for authorization and authentication on the web. Both protocols allow users to securely access resources, but they work in different ways and have different use cases. In this tutorial, we’ll compare OIDC and OAuth 2.0 to help you understand the key differences ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">Unbundling: The Natural Evolution of Tech Stacks</title><link rel="alternate" href="http://www.ofbizian.com/2023/01/the-unbundling-of-tech-stack.html" /><author><name>Unknown</name></author><id>http://www.ofbizian.com/2023/01/the-unbundling-of-tech-stack.html</id><updated>2023-01-03T10:53:00Z</updated><content type="html">As the field of IT continually evolves, there is a constant stream of new software architectures, development techniques, and tools. Some examples of these include microservices, micro frontends, zero trust, service mesh, and data mesh, you mesh it. Despite the apparent diversity of these technologies and approaches, they are all connected by a common trend: the unbundling of technology stacks and teams. This trend involves breaking down systems into smaller, independent components and organizing work into smaller, more focused teams in order to achieve greater flexibility, and modularity. The unbundling of the tech stack How come each of these represent unbundling? * Microservices emerged as a response to the limitations of monolithic architecture, which can be inflexible and difficult to scale and maintain as an application grows. By breaking a monolithic application into smaller, independent services, it becomes possible to develop, deploy, and scale each part of the application independently, leading to faster development cycles and greater flexibility. * Hexagonal architecture was developed to improve the flexibility and maintainability of 3-tier applications by decoupling components and providing standardized interfaces for interacting with them. * Domain-driven design (DDD) is a software development approach that can help break down a monolithic application into smaller, loosely-coupled modules that represent different business domains or contexts. * Micro frontends architecture is a design approach in which a large, monolithic frontend application is broken down into smaller, independent modules that can be developed and deployed separately.  * JAMstack decouples the frontend and backend of an application by separating the HTML, CSS, and JavaScript that make up the user interface from the server-side code and databases that power the application, allowing easier maintenance as changes to one part of the system do not necessarily require changes to the other. * A service mesh decouples the networking responsibilities of a distributed application, such as routing, load balancing, and service discovery, from the application itself, allowing developers to focus on building business logic and features without worrying about the underlying network infrastructure. * Similar to microservices, data mesh involves decomposing a large, complex system into smaller, independent components. It decomposes data governance and management practices into smaller, independent components that can be implemented and enforced consistently across different data sources and systems. * The 2 pizza team model is a strategy for organizing teams and work in organizations that advocates for smaller teams able to respond to changes more quickly, have better communication and collaboration, can make faster decisions and solve problems more efficiently. The end result of every tech trend is unbundling. Unbundling of technology stacks into independent components and teams into smaller, more focused teams likely to spread into all other areas. After frontend, data, networking, security, what do you think is the next area of unbundling? in working on and unbundling integration. Also follow me at  and shout out with any thoughts and comments on the topic of .</content><dc:creator>Unknown</dc:creator></entry><entry><title type="html">How to configure Java Memory in a Docker Container</title><link rel="alternate" href="http://www.mastertheboss.com/soa-cloud/docker/how-to-configure-java-memory-in-a-docker-container/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/soa-cloud/docker/how-to-configure-java-memory-in-a-docker-container/</id><updated>2023-01-02T15:52:04Z</updated><content type="html">When running a Java application in a Docker container, it is important to properly configure the JVM memory settings. This is essential to ensure that the application has enough memory to run correctly. If you don’t specify a value for the --memory flag when starting a Docker container, the container will be given an automatic ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title type="html">Solving java.lang.OutOfMemoryError: java heap space</title><link rel="alternate" href="http://www.mastertheboss.com/java/solving-java-lang-outofmemoryerror-java-heap-space/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/java/solving-java-lang-outofmemoryerror-java-heap-space/</id><updated>2023-01-02T14:30:07Z</updated><content type="html">This article goes through the most common Java OutOfMemory Error, which happens when you saturate the Java Heap Memory. Within this article we will show how to fix this error depending if you are an application user or an application developer. The Java Heap Space is the area of memory where the Java objects reside. ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry></feed>
